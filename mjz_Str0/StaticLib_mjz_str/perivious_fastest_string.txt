
template <class mjz_String_template_args_t>
using get_mjz_reallocator_t_from_mjz_String_template_args =
    typename mjz_String_template_args_t::mjz_reallocator_t;
template <class mjz_String_template_args_t = mjz_String_template_args<void>>
class mjz_String_template
    : public basic_mjz_Str_view<minimal_mjz_string_data<
          mjz_String_template_args_t::minimal_mjz_string_data_min_size>> {
  static constexpr const bool deafult_is_noexcept =
      !mjz_String_template_args_t::do_throw;
  using mjz_reallocator_t = get_mjz_reallocator_t_from_mjz_String_template_args<
      mjz_String_template_args_t>;
  using Base_t = minimal_mjz_string_data<
      mjz_String_template_args_t::minimal_mjz_string_data_min_size>;

  using str_view = basic_mjz_Str_view<deafult_mjz_Str_data_strorage>;
  constexpr static const char nullcr = '\0';
  constexpr static const uint8_t nullen = sizeof(nullcr) /*1*/;

 private:
  inline mjz_reallocator_t Allocator() const {
    if constexpr (std::is_constructible_v<
                      mjz_reallocator_t,
                      mjz_String_pointer_for_internal_realloc_id>)
      return {mjz_String_pointer_for_internal_realloc_id{.ptr = this}};
    return {};
  }
  succsess_t shrink_to_(size_t new_cap) {
    if (new_cap == get_cap()) return true;
    char *new_buffer{};
    char *old_buffer = get_buffer();
    { /*reallocate "https://linux.die.net/man/3/realloc" but with args
           (void*ptr,size_t pr_size,size_t new_size) [nonexpert]*/
      new_buffer = (char *)Allocator().mjz_realloc(
          old_buffer, get_cap() + nullen, new_cap + nullen);
    }
    if (!new_buffer) {
      free_buffer();
      return 0;
    }
    new_buffer[new_cap] = nullcr;
    get_Base_t().unsafe_set_cap(new_cap, new_buffer, 1);
    get_Base_t().set_len(new_cap);
    return 1;
  }

  void free_buffer() {
    if (is_dynamic()) {
      /*
        you could add memset 0 but performance :(
      */
      Allocator().mjz_free(get_buffer(), get_cap() + nullen);
    }
    get_Base_t().unsafe_reset();
  }
  succsess_t reallocate_bigger_buffer_(size_t new_cap) {
    if (get_Base_t().can_have_len(new_cap)) return 1;
    char *new_buffer{};
    char *old_buffer = get_buffer();
    const bool was_dynamic = is_dynamic();
    { /*reallocate "https://linux.die.net/man/3/realloc" but with args
           (void*ptr,size_t pr_size,size_t new_size) [nonexpert]*/
      new_buffer = (char *)/*sizeof(char)==1*/ Allocator().mjz_realloc(
          was_dynamic ? old_buffer : nullptr,
          was_dynamic ? get_cap() + nullen : 0, new_cap + nullen);
    }
    if (!new_buffer) {
      free_buffer();
      return 0;
    }

    /* requires(get_len()<new_cap)*/
    if (!was_dynamic) {
      const char *const perivuos_inner_buffer_that_will_be_invalid_after_call =
          old_buffer;
      memmove(new_buffer, perivuos_inner_buffer_that_will_be_invalid_after_call,
              get_len());
    }
    memset(new_buffer + get_len(), '\0', new_cap - get_len() + nullen);
    get_Base_t().unsafe_set_cap(new_cap, new_buffer, 1);
    return 1;
  }
  inline constexpr static succsess_t check_succsess(
      bool result, bool is_noexcept = deafult_is_noexcept) {
    if (result || is_noexcept) return result;
    Throw<const char *>("out of memory");
    return 0;  // just for ?
  }
  // private:
  constexpr inline Base_t &get_Base_t() { return *this; }
  constexpr inline const Base_t &get_Base_t() const { return *this; }
  inline const char *get_buffer() const { return get_Base_t().get_buffer(); }
  inline char *get_buffer() { return get_Base_t().get_buffer(); }
  inline size_t get_length() const { return get_Base_t().get_length(); }
  inline size_t get_len() const { return get_length(); }
  inline size_t get_cap() const { return get_Base_t().get_cap(); }
  inline size_t to_appropriate_size(size_t new_min_cap) const {
    constexpr static const bool log = mjz_do_debug;
    if constexpr (log) {
      std::cout << "new_min_cap:";
      std::cout << new_min_cap;
    }
    new_min_cap = max(min(length() * 2, (int)((length() + capacity()) * 1.5f)),
                      new_min_cap);
    if constexpr (log) {
      std::cout << " to ";
      std::cout << new_min_cap << '\n';
    }
    return new_min_cap;
  }

 public:
  inline bool is_dynamic() const { return get_Base_t().is_dynamic(); }
  inline size_t can_add_until_not_dynamic() const {
    return get_Base_t().can_add_until_not_dynamic();
  }
  inline size_t can_add_until_reallocation() const {
    return capacity() - length();
  }
  succsess_t resurve(size_t new_cap, bool can_shrink = false,
                     bool can_allocate_more = true,
                     bool noexpt = deafult_is_noexcept) {
    if (new_cap == capacity()) return 1;
    if (!get_Base_t().can_have_len(new_cap)) {
      return check_succsess(
          reallocate_bigger_buffer_(
              can_allocate_more ? to_appropriate_size(new_cap) : new_cap),
          noexpt);
    }
    if (!is_dynamic() || !can_shrink) return 1;
    return check_succsess(shrink_to_(new_cap), noexpt);
  }
  succsess_t resize(size_t new_len, bool noexpt = deafult_is_noexcept) {
    if (new_len == length()) return 1;
    if (!resurve(new_len, 0, 1, noexpt)) return 0;
    get_Base_t().set_len(new_len);
    get_buffer()[new_len] = nullcr;
    return 1;
  }
  inline succsess_t add_length(size_t addition_to_len,
                               bool noexpt = deafult_is_noexcept) {
    return resize(get_len() + addition_to_len, noexpt);
  }
  inline const char *C_str() const { return get_buffer(); }
  inline char *data() { return get_buffer(); }
  inline char *c_str() { return data(); }
  inline const char *c_str() const { return C_str(); }
  inline size_t length() const { return get_len(); }
  inline size_t capacity() const { return get_cap(); }
  inline char *begin() { return c_str(); }
  inline char *end() { return c_str() + get_len(); }
  inline const char *begin() const { return c_str(); }
  inline const char *end() const { return c_str() + get_len(); }
  inline const char *cbegin() const { return begin(); }
  inline const char *cend() const { return end(); }
  using r_it_T = std::reverse_iterator<char *>;
  using cr_it_T = std::reverse_iterator<const char *>;
  inline r_it_T rbegin() { return end(); }
  inline r_it_T rend() { return begin(); }
  inline cr_it_T rbegin() const { return end(); }
  inline cr_it_T rend() const { return begin(); }
  inline cr_it_T crbegin() const { return end(); }
  inline cr_it_T crend() const { return begin(); }
  inline mjz_String_template() {}
  explicit inline mjz_String_template(mjz_String_template &&other) noexcept {
    if (this == &other) return;
    get_Base_t().move_to_me(std::move(other.get_Base_t()));
  }

  explicit inline mjz_String_template(const mjz_String_template &other,
                                      bool noexpt = deafult_is_noexcept) {
    if (this == &other) return;
    if (!resize(other.length(), 1)) {
      check_succsess(0, noexpt);
      return;
    }
    memmove(data(), other.C_str(), other.length());
    *end() = nullcr;
  }
  template <class T>
  explicit inline mjz_String_template(const basic_mjz_Str_view<T> &other,
                                      bool noexpt = deafult_is_noexcept)
    requires(!std::same_as<Base_t, T>)
  {
    copy_from(other, noexpt);
  }

  inline mjz_String_template &operator=(str_view &&other) {
    return copy_from(other);
  }

  mjz_String_template &operator=(mjz_String_template &&other) {
    if (this == &other) return *this;
    free_buffer();
    get_Base_t().move_to_me(std::move(other.get_Base_t()));
    return *this;
  }

  template <class T>
  inline mjz_String_template &copy_from(const basic_mjz_Str_view<T> &other,
                                        bool noexpt = deafult_is_noexcept,
                                        bool *successful_out = nullptr) {
    if (successful_out) *successful_out = true;
    if (!resize(other.length(), 1)) {
      if (successful_out) *successful_out = 0;
      check_succsess(0, noexpt);
      return *this;
    }
    if (data() == other.data()) {
      return *this;
    }
    memmove(data(), other.data(), other.length());
    *end() = nullcr;
    return *this;
  }

  template <class T>
  inline mjz_String_template &append(const basic_mjz_Str_view<T> &other,
                                     bool noexpt = deafult_is_noexcept,
                                     bool *successful_out = nullptr) {
    if (successful_out) *successful_out = true;
    const size_t per_len = length();
    const size_t len_add = other.length();
    if (!add_length(len_add, 1)) {
      if (successful_out) *successful_out = 0;
      check_succsess(0, noexpt);
      return *this;
    }
    memmove(data() + per_len, other.data(), len_add);
    *end() = nullcr;
    return *this;
  }

  template <class T>
  inline mjz_String_template &operator=(const basic_mjz_Str_view<T> &other) {
    return copy_from(other);
  }
  inline mjz_String_template &operator=(const str_view &other) {
    return copy_from(other);
  }
  inline mjz_String_template &operator=(const mjz_String_template &other) {
    return copy_from(other);
  }

  template <class T>
  inline mjz_String_template &operator+=(const basic_mjz_Str_view<T> &other) {
    return append(other);
  }
  template <class T>
  inline mjz_String_template &operator+=(T &&val)
    requires requires() { this->concat(val); }
  {
    concat(val);
    return *this;
  }
  inline mjz_String_template &operator+=(const str_view &other) {
    return append(other);
  }
  inline mjz_String_template &operator+=(const mjz_String_template &other) {
    return append(other);
  }
  template <class T>
  inline bool concat(const basic_mjz_Str_view<T> &other,
                     bool noexpt = deafult_is_noexcept) {
    bool was_succsessful{};
    append(other, noexpt, &was_succsessful);
    return check_succsess(was_succsessful, noexpt);
  }
  using ALGO = static_str_algo;
  bool concat(const char *cstr, size_t length) {
    return concat(str_view{cstr, length});
  }
  template <size_t N>
  bool concat(const char (&const a)[N]) {
    return concat(str_view{a, N - 1});
  }
  bool concat(const uint8_t *cstr, size_t length) {
    return concat((const char *)cstr, length);
  }
  bool concat(char c) { return concat(str_view{&c, 1}); }
  bool concat(unsigned char num) {
    char buf[1 + 3 * sizeof(unsigned char)];
    return concat(buf, ALGO::itoa(num, buf, 10).len);
  }
  bool concat(int num) {
    char buf[2 + 3 * sizeof(int)];
    return concat(buf, ALGO::itoa(num, buf, 10).len);
  }
  bool concat(unsigned int num) {
    char buf[1 + 3 * sizeof(unsigned int)];
    return concat(buf, ALGO::utoa(num, buf, 10).len);
  }
  bool concat(long num) {
    char buf[2 + 3 * sizeof(long)];
    return concat(buf, ALGO::ltoa(num, buf, 10).len);
  }

  bool concat(unsigned long num) {
    char buf[1 + 3 * sizeof(unsigned long)];
    return concat(buf, ALGO::ultoa(num, buf, 10).len);
  }

  bool concat(int64_t num) {
    char buf[2 + 3 * sizeof(int64_t)];
    return concat(buf, ALGO::lltoa(num, buf, 10).len);
  }

  bool concat(uint64_t num) {
    char buf[1 + 3 * sizeof(uint64_t)];
    return concat(buf, ALGO::ulltoa(num, buf, 10).len);
  }
  template <typename JUST_VOID_PTR = const void *>
  bool concat(JUST_VOID_PTR ptr)
    requires(std::is_same_v<std::remove_cvref_t<JUST_VOID_PTR>, void *>)
  {
    char buf[1 + 3 * sizeof(const void *)];
    const uint64_t val = (uint64_t)ptr;
    return concat(buf,
                  ALGO::b_U_lltoa_n(val, buf, NumberOf(buf), 16, 0, 0, 1).len);
  }

  bool concat(float num) {
    char buf[22];
    auto [string, len] = ALGO::dtostrf(num, 4, 2, buf, 21);
    return concat(string, len);
  }

  bool concat(double num) {
    char buf[42];
    auto [string, len] = ALGO::dtostrf(num, 4, 2, buf, 41);
    return concat(string, len);
  }
  static inline char dummy_writable_char{};
  static bool is_dummy_char(const char &c) {
    return &dummy_writable_char == &c;
  }
  inline bool valid_index(size_t i) const {
    return get_Base_t().can_have_len(i + 1);
  }
  inline succsess_t add_filled_length(char fill_var, size_t addition_to_len,
                                      bool noexpt = deafult_is_noexcept) {
    size_t pr_len = length();
    if (!add_length(addition_to_len, noexpt)) return 0;
    ALGO::memset(data() + pr_len, fill_var, addition_to_len);
    *end() = nullcr;
    return true;
  }
  char &operator[](size_t index) {
    if (!valid_index(index)) {
      dummy_writable_char = 0;
      return dummy_writable_char;
    }
    return data()[index];
  }

  bool setCharAt(unsigned int loc, char c) {
    if (loc >= length()) return 0;
    data()[loc] = c;
    return 1;
  }
  inline bool has_any_data() const { return get_Base_t().has_any_data(); }
  bool trim(bool noexpt = deafult_is_noexcept) {
    return resurve(length(), 1, 0, noexpt);
  }
  inline str_view view() const { return {C_str(), length()}; }
  inline operator str_view() const { return view(); }
  inline explicit operator bool() const { return !!*this; }
  ~mjz_String_template() { free_buffer(); }
  inline void operator~() { free_buffer(); }
  inline int64_t operator+() { return view().toLL(); }
  template <typename T>
  struct mjz_is_castable_int_t
      : std::integral_constant<bool, std::is_integral_v<T> &&
                                         !std::is_same_v<T, bool> &&
                                         !std::is_same_v<T, char> &&
                                         !std::is_same_v<T, unsigned char>> {};
  template <t_to_concept<mjz_is_castable_int_t> T>
  inline operator T() {
    return view().toLL();
  }

  explicit mjz_String_template(unsigned char value, unsigned char base = 10) {
    char buf[1 + 8 * sizeof(unsigned char)];
    auto [str, len] = ALGO::utoa(value, buf, base);
    copy_from(str_view(str, len));
  }

  explicit mjz_String_template(int value, unsigned char base = 10) {
    char buf[2 + 8 * sizeof(int)];
    auto [str, len] = ALGO::itoa(value, buf, base);
    copy_from(str_view(str, len));
  }

  explicit mjz_String_template(unsigned int value, unsigned char base = 10) {
    char buf[1 + 8 * sizeof(unsigned int)];
    auto [str, len] = ALGO::utoa(value, buf, base);
    copy_from(str_view(str, len));
  }

  explicit mjz_String_template(long value, unsigned char base = 10) {
    char buf[2 + 8 * sizeof(long)];
    auto [str, len] = ALGO::ltoa(value, buf, base);
    copy_from(str_view(str, len));
  }

  explicit mjz_String_template(unsigned long value, unsigned char base = 10) {
    char buf[1 + 8 * sizeof(unsigned long)];
    auto [str, len] = ALGO::ultoa(value, buf, base);
    copy_from(str_view(str, len));
  }

  template <std::same_as<const void *> V>
  explicit mjz_String_template(V ptr) {
    concat(ptr);
  }
  explicit mjz_String_template(int64_t value, unsigned char base = 10) {
    char buf[2 + 8 * sizeof(int64_t)];
    auto [str, len] = ALGO::ltoa(value, buf, base);
    copy_from(str_view(str, len));
  }

  explicit mjz_String_template(uint64_t value, unsigned char base = 10) {
    char buf[1 + 8 * sizeof(uint64_t)];
    auto [str, len] = ALGO::ultoa(value, buf, base);
    copy_from(str_view(str, len));
  }

  explicit mjz_String_template(float value, unsigned char decimalPlaces = 2) {
    static size_t const FLOAT_BUF_SIZE =
        FLT_MAX_10_EXP + ALGO::FLT_MAX_DECIMAL_PLACES + 1 /* '-' */ +
        1 /* '.' */ + 1 /* '\0' */;

    char buf[FLOAT_BUF_SIZE];
    decimalPlaces = min(decimalPlaces, ALGO::FLT_MAX_DECIMAL_PLACES);
    auto [str, len] = ALGO::dtostrf(value, (decimalPlaces + 2), decimalPlaces,
                                    buf, NumberOf(buf));
    copy_from(str_view(str, len));
  }

  explicit mjz_String_template(double value, unsigned char decimalPlaces = 2) {
    static size_t const DOUBLE_BUF_SIZE =
        DBL_MAX_10_EXP + ALGO::DBL_MAX_DECIMAL_PLACES + 1 /* '-' */ +
        1 /* '.' */ + 1 /* '\0' */;

    char buf[DOUBLE_BUF_SIZE];
    decimalPlaces = min(decimalPlaces, ALGO::DBL_MAX_DECIMAL_PLACES);
    auto [str, len] = ALGO::dtostrf(value, (decimalPlaces + 2), decimalPlaces,
                                    buf, NumberOf(buf));
    copy_from(str_view(str, len));
  }

  inline mjz_String_template(const str_view &other,
                             bool noexpt = deafult_is_noexcept) {
    copy_from(other, noexpt);
  }
  inline mjz_String_template(str_view &&other,
                             bool noexpt = deafult_is_noexcept) {
    copy_from(other, noexpt);
  }

  mjz_String_template &toLowerCase(void) {
    char *ptr = begin();
    char *const end_ptr = end();
    constexpr static const char after_a = 'A' - 1;
    constexpr static const char before_z = 'Z' + 1;
    constexpr static const int upper_to_lower_offset = int('a') - int('A');
    while (ptr++ != end_ptr) {
      if (after_a < *ptr && *ptr < before_z)
        *ptr = *ptr + upper_to_lower_offset;
    }
  }
  mjz_String_template &toUpperCase(void) {
    char *ptr = begin();
    char *const end_ptr = end();
    constexpr static const char after_a = 'a' - 1;
    constexpr static const char before_z = 'z' + 1;
    constexpr static const int neg_lower_to_upper_offset = int('a') - int('A');
    while (ptr++ != end_ptr) {
      if (after_a < *ptr && *ptr < before_z)
        *ptr = *ptr - neg_lower_to_upper_offset;
    }
  }

  succsess_t replace(char find, char replace) {
    for (char &c : *this) c = (c == find ? replace : c);
    return true;
  }

 private:
  static size_t find_multi_on_valid_str_(const char *hay_stack,
                                         size_t hay_stack_len,
                                         const char *needle,
                                         size_t needel_len) {
    size_t found{};
    const char *str = hay_stack;
    size_t len = hay_stack_len;
    char first_char = *needle;
    while (true) {
      while (len && first_char != *str) {
        ++str;
        --len;
      }

      if (!len) return found;
      size_t needel_reamain = needel_len;
      const char *needle_ptr = needle;
      while (len && needel_reamain && *str == *needle_ptr) {
        needel_reamain--;
        len--;
        needle_ptr++;
        str++;
      }
      if (!needel_reamain) ++found;
      if (!len) return found;
    }
  }

 public:
  succsess_t replace(const str_view &find, const str_view &replace,
                     bool noexpt = deafult_is_noexcept) {
    if (!find.length()) return false;
    if (length() < find.length()) return true;
    const char *const ptr_find = find.data();
    const char *const ptr_replace = replace.data();
    const size_t len_find = find.length();
    const size_t len_replace = replace.length();
    const size_t per_len = length();
    // find the number of strings maching find
    size_t num = find_multi_on_valid_str_(C_str(), per_len, ptr_find, len_find);
    int64_t delta_length = num * (len_replace - len_find);
    if (delta_length == 0) return true;
    char *src_ptr = 0;
    char *dest_ptr = 0;
    if (delta_length > 0) {
      bool succsess = add_length(delta_length, noexpt);
      if (!succsess) return check_succsess(0, noexpt);
      char *const data_buffer_ptr = data() + delta_length;
      char *const data_storage = data();
      memmove(data_buffer_ptr, data_storage, per_len);
      // move back and replace
      src_ptr = data_buffer_ptr;
      dest_ptr = data_storage;
    } else {
      // emplace replace
      src_ptr = data();
      dest_ptr = src_ptr;
    }
    /*like below FIND -> REPLACE
     * -> resize
     * "helloFINDworld   "'\0'
     * -> move to front( "hel""==###" but that is invalid  )
     * "###helloFINDworld"'\0'
     * -> with block move backs(the core part)
     * "helloREPLACEworld"'\0'
     */
    const char first_char = *ptr_find;
    const char *const finde_ptr_ = ptr_find;
    const size_t finde_len_ = len_find;
    size_t len = per_len;
    while (true) {
      while (len && first_char != *src_ptr) {
        *dest_ptr++ = *src_ptr++;
        --len;
      }
      if (!len) break;

      const char *finder_ptr = finde_ptr_;
      size_t finder_len = finde_len_;
      if (len < finder_len) {
        ALGO::memmove(dest_ptr, src_ptr, len);
        break;
      }
      bool is_equal = ALGO::mem_equals(src_ptr, finder_ptr, finder_len);
      if (is_equal) {
        ALGO::memmove(dest_ptr, ptr_replace, len_replace);
        len -= finder_len;
        src_ptr += finder_len;
        dest_ptr += len_replace;
      } else {
        *dest_ptr++ = *src_ptr++;
        --len;
      }
    }
    return resize((int64_t)per_len + delta_length, noexpt);
  }
  succsess_t remove(size_t index, bool noexpt = deafult_is_noexcept) {
    if (!valid_index(index)) return false;
    return resize(index + 1, noexpt);
  }
  succsess_t remove(size_t index, size_t count,
                    bool noexpt = deafult_is_noexcept) {
    if (!valid_index(index)) return false;
    char *dest_ptr = data() + index;
    char *src_ptr = dest_ptr + count;
    ALGO::memmove(dest_ptr, src_ptr, count);
    return resize(length() - count, noexpt);
  }
  succsess_t insert(size_t index, char val, size_t count,
                    bool noexpt = deafult_is_noexcept) {
    char *index_ptr_ret{};
    if (!insert_invalid(index, count, &index_ptr_ret, noexpt)) return false;
    ALGO::memset(index_ptr_ret, val, count);
  }
  inline succsess_t insert_invalid(size_t index, size_t count,
                                   char **index_ptr_,
                                   bool noexpt = deafult_is_noexcept) {
    size_t per_len = length();
    if (!add_length(count, noexpt)) return false;
    char *index_ptr = data() + index;
    if (index_ptr_) *index_ptr_ = index_ptr;
    ALGO::memmove(index_ptr + count, index_ptr, per_len - index);
    return true;
  }
  succsess_t insert(size_t index, const char *string, size_t count,
                    bool noexpt = deafult_is_noexcept) {
    char *index_ptr_ret{};
    if (!insert_invalid(index, count, &index_ptr_ret, noexpt)) return false;
    ALGO::memmove(index_ptr_ret, string, count);
  }
  succsess_t insert(size_t index, str_view str,
                    bool noexpt = deafult_is_noexcept) {
    return insert(index, str.data(), str.length(), noexpt);
  }

  friend void inline constexpr static_assert_if_mjz_string_hase_bad_size();
};
inline constexpr void static_assert_if_mjz_string_hase_bad_size() {
  using str_mjz = mjz_String_template<mjz_String_template_args<void>>;
  static_assert(sizeof(typename str_mjz::Base_t) == sizeof(str_mjz));
}

namespace have_mjz_ard_removed {
using mjz_String = mjz_String_template<mjz_String_template_args<void>>;
using mjz_String_view = basic_mjz_Str_view<deafult_mjz_Str_data_strorage>;
}  // namespace have_mjz_ard_removed